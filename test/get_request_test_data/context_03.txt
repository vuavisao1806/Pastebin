{"pasteValue":"architecture is the answer, what was the question? This chapter focuses on why architecture matters from a technical perspective. We will examine a baker’s dozen of the most important reasons. You can use these reasons to moti vate the creation of a new architecture, or the analysis and evolution of an existing system’s architecture. 1. 2. 3. 4. 5. 6. 7. 8. 9. An architecture can either inhibit or enable a system’s driving quality attributes. The decisions made in an architecture allow you to reason about and manage change as the system evolves. The analysis of an architecture enables early prediction of a system’s qualities. A documented architecture enhances communication among stakeholders. The architecture is a carrier of the earliest, and hence most-fundamental, hardest-to change design decisions. An architecture defines a set of constraints on subsequent implementation. The architecture dictates the structure of an organization, or vice versa. An architecture can provide the basis for incremental development. An architecture is the key artifact that allows the architect and the project manager to reason about cost and schedule. 10. An architecture can be created as a transferable, reusable model that forms the heart of a product line. 11. Architecture-based development focuses attention on the assembly of components, rather than simply on their creation. 12. By restricting design alternatives, architecture channels the creativity of developers, reducing design and system complexity. 13. An architecture can be the foundation for training of a new team member. 25 26 Part I Introduction | Chapter 2 Why Is Software Architecture Important? Even if you already believe us that architecture is important and don’t need that point hammered home 13 more times, think of these 13 points (which form the outline for this chap ter) as 13 useful ways to use architecture in a project, or to justify the resources devoted to architecture. 2.1 Inhibiting or Enabling a System’s Quality Attributes A system’s ability to meet its desired (or required) quality attributes is substantially deter mined by its architecture. If you remember nothing else from this book, remember that. This relationship is so important that we’ve devoted all of Part II of this book to expound ing that message in detail. Until then, keep these examples in mind as a starting point: If your system requires high performance, then you need to pay attention to managing the time-based behavior of elements, their use of shared resources, and the frequency and volume of their interelement communication. If modifiability is important, then you need to pay attention to assigning responsibilities to elements and limiting the interactions (coupling) of those elements so that the major ity of changes to the system will affect a small number of those elements. Ideally, each change will affect just a single element. If your system must be highly secure, then you need to manage and protect interelement communication and control which elements are allowed to access which information. You may also need to introduce specialized elements (such as an authorization mechanism) into the architecture to set up a strong “perimeter” to guard against intrusion. If you want your system to be safe and secure, you need to design in safeguards and recovery mechanisms. If you believe that scalability of performance will be important to the success of your system, then you need to localize the use of resources to facilitate the introduction of higher-capacity replacements, and you must avoid hard-coding in resource assumptions or limits. If your projects need the ability to deliver incremental subsets of the system, then you must manage intercomponent usage. If you want the elements from your system to be reusable in other systems, then you need to restrict interelement coupling so that when you extract an element, it does not come out with too many attachments to its current environment to be useful. The strategies for these and other quality attributes are supremely architectural. But an architecture alone cannot guarantee the functionality or quality required of a system. Poor downstream design or implementation decisions can always undermine an adequate architec tural design. As we like to say (mostly in jest): What the architecture giveth, the implementa tion may taketh away. Decisions at all stages of the life cycle—from architectural design to coding and implementation and testing—affect system quality. Therefore, quality is not com pletely a function of an architectural design. But that’s where it starts. 2.2 Reasoning about and Managing Change 27 2.2 Reasoning about and Managing Change This is a corollary to the previous point. Modifiability—the ease with which changes can be made to a system— is a quality attri bute (and hence covered by the arguments in the previous section), but it is such an important quality that we have awarded it its own spot in the List of Thirteen. The software development community is coming to grips with the fact that roughly 80 percent of a typical software sys tem’s total cost occurs after initial deployment. Most systems that people work on are in this phase. Many programmers and software designers never get to work on new development— they work under the constraints of the existing architecture and the existing body of code. Virtually all software systems change over their lifetimes, to accommodate new features, to adapt to new environments, to fix bugs, and so forth. But the reality is that these changes are often fraught with difficulty. Every architecture, no matter what it is, partitions possible changes into three categories: local, nonlocal, and architectural. A local change can be accomplished by modifying a single element—for example, add ing a new business rule to a pricing logic module. A nonlocal change requires multiple element modifications but leaves the underlying architectural approach intact—for example, adding a new business rule to a pricing logic module, then adding new fields to the database that this new business rule requires, and then revealing the results of applying the rule in the user interface. An architectural change affects the fundamental ways in which the elements interact with each other and will probably require changes all over the system—for example, changing a system from single-threaded to multi-threaded. Obviously, local changes are the most desirable, so an effective architecture is one in which the most common changes are local, and hence easy to make. Nonlocal changes are not as desirable but do have the virtue that they can usually be staged—that is, rolled out—in an orderly manner over time. For example, you might first make changes to add a new pricing rule, then make the changes to actually deploy the new rule. Deciding when changes are essential, determining which change paths have the least risk, assessing the consequences of proposed changes, and arbitrating sequences and priorities for requested changes all require broad insight into the relationships, performance, and behaviors of system software elements. These tasks are all part of the job description for an architect. Reasoning about the architecture and analyzing the architecture can provide the insights nec essary to make decisions about anticipated changes. If you do not take this step, and if you do not pay attention to maintaining the conceptual integrity of your architecture, then you will almost certainly accumulate architecture debt. We deal with this subject in Chapter 23. 28 Part I Introduction | Chapter 2 Why Is Software Architecture Important? 2.3 Predicting System Qualities This point follows from the previous two: Architecture not only imbues systems with qualities, but does so in a predictable way. This may seem obvious, but it need not be the case. Then designing an architecture would consist of making a series of pretty much random design decisions, building the system, test ing for quality attributes, and hoping for the best. Oops—not fast enough or hopelessly vulner able to attacks? Start hacking. Fortunately, it is possible to make quality predictions about a system based solely on an evaluation of its architecture. If we know that certain kinds of architectural decisions lead to certain quality attributes in a system, then we can make those decisions and rightly expect to be rewarded with the associated quality attributes. After the fact, when we examine an architecture, we can determine whether those decisions have been made and confidently pre dict that the architecture will exhibit the associated qualities. This point and the previous point, taken together, mean that architecture largely deter mines system qualities and—even better!—we know how it does so, and we know how to make it do so. Even if you don’t perform the quantitative analytic modeling sometimes necessary to ensure that an architecture will deliver its prescribed benefits, this principle of evaluating decisions based on their quality attribute implications is invaluable for at least spotting poten tial trouble early. 2.4 Communication among Stakeholders One point made in Chapter 1 is that an architecture is an abstraction, and that is useful because it represents a simplified model of the whole system that (unlike the infinite details of the whole system) you can keep in your head. So can others on your team. Architecture represents a common abstraction of a system that most, if not all, of the system’s stakeholders can use as a basis for creating mutual understanding, negotiating, forming consensus, and communicating with each other. The architecture—or at least parts of it—are sufficiently abstract that most nontechnical people can understand it to the extent they need to, particularly with some coach ing from the architect, and yet that abstraction can be refined into sufficiently rich technical specifications to guide implementation, integration, testing, and deployment. Each stakeholder of a software system—customer, user, project manager, coder, tester, and so on—is concerned with different characteristics of the system that are affected by its architecture. For example: the user is concerned that the system is fast, reliable, and available when needed; the customer (who pays for the system) is concerned that the architecture can be imple mented on schedule and according to budget; 2.4 Communication among Stakeholders 29 the manager is worried that (in addition to cost and schedule concerns) the architecture will allow teams to work largely independently, interacting in disciplined and controlled ways; and the architect is worried about strategies to achieve all of those goals. Architecture provides a common language in which different concerns can be expressed, negotiated, and resolved at a level that is intellectually manageable even for large, complex systems. Without such a language, it is difficult to understand large systems sufficiently to make the early decisions that influence both quality and usefulness. Architectural analysis, as we will see in Chapter 21, both depends on this level of communication and enhances it. Chapter 22, on architecture documentation, covers stakeholders and their concerns in greater depth. “What Happens When I Push This Button?”: Architecture as a Vehicle for Stakeholder Communication The project review droned on and on. The government-sponsored development was behind schedule and over budget, and it was large enough that these lapses were attracting the U.S. Congress’s attention. And now the government was making up for past neglect by holding a marathon come-one-come-all review session. The contractor had recently undergone a buyout, which hadn’t helped matters. It was the afternoon of the second day, and the agenda called for presentation of the software architecture. The young architect—an apprentice to the chief architect for the system—was bravely explaining how the software architecture for the massive system would enable it to meet its very demanding real-time, distributed, high-reliability requirements. He had a solid presentation and a solid architecture to present. It was sound and sensible. But the audience—about 30 government representatives who had varying roles in the manage ment and oversight of this sticky project—was tired. Some of them were even thinking that perhaps they should have gone into real estate instead of enduring another one of these marathon let’s-finally-get-it-right-this-time reviews. The slide showed, in semiformal box-and-line notation, what the major software elements were in a runtime view of the system. The names were all acronyms, sug gesting no semantic meaning without explanation, which the young architect gave. The lines showed data flow, message passing, and process synchronization. The elements were internally redundant, as the architect was explaining. “In the event of a failure,” he began, using a laser pointer to denote one of the lines, “a restart mechanism triggers along this path when. . . .” “What happens when the mode select button is pushed?” interrupted one of the audience members. He was a government attendee representing the user community for this system. “Beg your pardon?” asked the architect. “The mode select button,” he said. “What happens when you push it?” “Um, that triggers an event in the device driver, up here,” began the architect, laser-pointing. “It then reads the register and interprets the event code. If it’s mode select, well, then, it signals the blackboard, which in turn signals the objects that have subscribed to that event. . . .” 30 Part I Introduction | Chapter 2 Why Is Software Architecture Important? “No, I mean what does the system do,” interrupted the questioner. “Does it reset the displays? And what happens if this occurs during a system reconfiguration?” The architect looked a little surprised and flicked off the laser pointer. This was not an architectural question, but since he was an architect and therefore fluent in the require ments, he knew the answer. “If the command line is in setup mode, the displays will reset,” he said. “Otherwise, an error message will be put on the control console, but the signal will be ignored.” He put the laser pointer back on. “Now, the restart mechanism that I was talking about. . . .” “Well, I was just wondering,” said the users’ delegate. “Because I see from your chart that the display console is sending signal traffic to the target location module.” “What should happen?” asked another member of the audience, addressing the first questioner. “Do you really want the user to get mode data during its reconfiguring?” And for the next 45 minutes, the architect watched as the audience consumed his time slot by debating what the correct behavior of the system was supposed to be in various esoteric states—an absolutely essential conversation that should have happened when the requirements were being formulated but, for whatever reason, had not. The debate was not architectural, but the architecture (and the graphical rendition of it) had sparked debate. It is natural to think of architecture as the basis for communica tion among some of the stakeholders besides the architects and developers: Managers, for example, use the architecture to create teams and allocate resources among them. But users? The architecture is invisible to users, after all; why should they latch on to it as a tool for system understanding? The fact is that they do. In this case, the questioner had sat through two days of view graphs all about function, operation, user interface, and testing. But it was the first slide on architecture that—even though he was tired and wanted to go home—made him realize he didn’t understand something. Attendance at many architecture reviews has convinced me that seeing the system in a new way prods the mind and brings new questions to the surface. For users, architecture often serves as that new way, and the questions that a user poses will be behavioral in nature. In a memorable architecture evaluation exercise a few years ago, the user representatives were much more interested in what the system was going to do than in how it was going to do it, and naturally so. Up until that point, their only contact with the vendor had been through its marketers. The architect was the first legitimate expert on the system to whom they had access, and they didn’t hesitate to seize the moment. Of course, careful and thorough requirements specifications would ameliorate this, but for a variety of reasons, they are not always created or available. In their absence, a specification of the architecture often serves to trigger questions and improve clarity. It is probably more prudent to recognize this possibility than to resist it. Sometimes such an exercise will reveal unreasonable requirements, whose utility can then be revisited. A review of this type that emphasizes synergy between require ments and architecture would have let the young architect in our story off the hook by giving him a place in the overall review session to address that kind of information. And the user representative wouldn’t have felt like a fish out of water, asking his question at a clearly inappropriate moment. —PCC 2.6 Constraints on Implementation 31 2.5 Early Design Decisions Software architecture is a manifestation of the earliest design decisions about a system, and these early bindings carry enormous weight with respect to the system’s remaining devel opment, its deployment, and its maintenance life. It is also the earliest point at which these important design decisions affecting the system can be scrutinized. Any design, in any discipline, can be viewed as a sequence of decisions. When painting a picture, an artist decides on the material for the canvas and the media for recording—oil paint, watercolor, crayon—even before the picture is begun. Once the picture is begun, other deci sions are immediately made: Where is the first line, what is its thickness, what is its shape? All of these early design decisions have a strong influence on the final appearance of the picture, and each decision constrains the many decisions that follow. Each decision, in isolation, might appear innocent enough, but the early ones in particular have disproportionate weight simply because they influence and constrain so much of what follows. So it is with architecture design. An architecture design can also be viewed as a set of decisions. Changing these early decisions will cause a ripple effect, in terms of the addi tional decisions that must now be changed. Yes, sometimes the architecture must be refactored or redesigned, but this is not a task we undertake lightly—because the “ripple” might turn into an avalanche. What are these early design decisions embodied by software architecture? Consider: Will the system run on one processor or be distributed across multiple processors? Will the software be layered? If so, how many layers will there be? What will each one do? Will components communicate synchronously or asynchronously? Will they interact by transferring control or data, or both? Will the information that flows through the system be encrypted? Which operating system will we use? Which communication protocol will we choose? Imagine the nightmare of having to change any of these or a myriad of other related decisions. Decisions like these begin to flesh out some of the structures of the architecture and their interactions. 2.6 Constraints on Implementation If you want your implementation to conform to an architecture, then it must conform to the design decisions prescribed by the architecture. It must have the set of elements prescribed by the architecture, these elements must interact with each other in the fashion prescribed by the architecture, and each element must fulfill its responsibility to the other elements as prescribed by the architecture. Each of these prescriptions is a constraint on the implementer. 32 Part I Introduction | Chapter 2 Why Is Software Architecture Important? Element builders must be fluent in the specifications of their individual elements, but they may not be aware of the architectural tradeoffs—the architecture (or architect) simply constrains them in such a way as to meet the tradeoffs. A classic example is when an archi tect assigns performance budgets to the pieces of software involved in some larger piece of functionality. If each software unit stays within its budget, the overall transaction will meet its performance requirement. Implementers of each of the constituent pieces may not know the overall budget, but only their own. Conversely, the architects need not be experts in all aspects of algorithm design or the intricacies of the programming language—although they should certainly know enough not to design something that is difficult to build. Architects, however, are the people responsible for establishing, analyzing, and enforcing the architectural decisions and tradeoffs. 2.7 Influences on Organizational Structure Not only does architecture prescribe the structure of the system being developed, but that structure becomes engraved in the structure of the development project (and sometimes the structure of the entire organization). The normal method for dividing up the labor in a large project is to assign different groups different portions of the system to construct. This so-called work-breakdown structure of a system is manifested in the architecture in the work assignment structure described in Chapter 1. Because the architecture includes the broadest decompo sition of the system, it is typically used as the basis for the work-breakdown structure. The work-breakdown structure in turn dictates units of planning, scheduling, and budget; inter team communication channels; configuration control and file-system organization; integration and test plans and procedures; and even project minutiae such as how the project intranet is organized and who sits with whom at the company picnic. Teams communicate with each other in terms of the interface specifications for their elements. The maintenance activity, when launched, will also reflect the software structure, with teams formed to maintain spe cific elements from the architecture—the database, the business rules, the user interface, the device drivers, and so forth. A side effect of establishing the work-breakdown structure is to freeze some aspects of the software architecture. A group that is responsible for one of the subsystems may resist having its responsibilities distributed across other groups. If these responsibilities have been formalized in a contractual relationship, changing responsibilities could become expensive or even litigious. Thus, once the architecture has been agreed upon, it becomes very costly—for manage rial and business reasons—to significantly modify it. This is one argument (among many) for analyzing the software architecture for a large system before settling on a specific choice. 2.9 Cost and Schedule Estimates 33 2.8 Enabling Incremental Development Once an architecture has been defined, it can serve as the basis for incremental development. The first increment can be a skeletal system in which at least some of the infrastructure—how the elements initialize, communicate, share data, access resources, report errors, log activity, and so forth—is present, but much of the system’s application functionality is not. Building the infrastructure and building the application functionality can go hand in hand. Design and build a little infrastructure to support a little end-to-end functionality; repeat until done. Many systems are built as skeletal systems that can be extended using plug-ins, packages, or extensions. Examples include the R language, Visual Studio Code, and most web browsers. The extensions, when added, provide additional functionality over and above what is present in the skeleton. This approach aids the development process by ensuring that the system is exe cutable early in the product’s life cycle. The fidelity of the system increases as extensions are added, or early versions are replaced by more complete versions of these parts of the software. In some cases, the parts may be low-fidelity versions or prototypes of the final functionality; in other cases, they may be surrogates that consume and produce data at the appropriate rates but do little else. Among other things, this allows potential performance (and other) problems to be identified early in the product’s life cycle. This practice gained attention in the early 2000s through the ideas of Alistair Cockburn and his notion of a “walking skeleton.” More recently, it has been adopted by those employing MVP (minimum viable product) as a strategy for risk reduction. The benefits of incremental development include a reduction of the potential risk in the project. If the architecture is for a family of related systems, the infrastructure can be reused across the family, lowering the per-system cost of each. 2.9 Cost and Schedule Estimates Cost and schedule estimates are an important tool for the project manager. They help the proj ect manager acquire the necessary resources as well as monitor progress on the project. One of the duties of an architect is to help the project manager create cost and schedule estimates early in the project’s life cycle. While top-down estimates are useful for setting goals and apportioning budgets, cost estimations based on a bottom-up understanding of the system’s pieces are typically more accurate than those based purely on top-down system knowledge. As we have said, the organizational and work-breakdown structure of a project is almost always based on its architecture. Each team or individual responsible for a work item will be able to make more accurate estimates for their piece than a project manager can, and will feel more ownership in making those estimates come true. But the best cost and schedule esti mates will typically emerge from a consensus between the top-down estimates (created by the 34 Part I Introduction | Chapter 2 Why Is Software Architecture Important? architect and the project manager) and the bottom-up estimates (created by the developers). The discussion and negotiation that result from this process create a far more accurate esti mate than the use of either approach by itself. It helps if the requirements for a system have been reviewed and validated. The more up-front knowledge you have about the scope, the more accurate the cost and schedule esti mates will be. Chapter 24 delves into the use of architecture in project management. 2.10 Transferable, Reusable Model The earlier in the life cycle reuse is applied, the greater the benefit that can be achieved from this practice. While code reuse offers a benefit, reuse of architectures provides opportunities for tremendous leverage for systems with similar requirements. When architectural decisions can be reused across multiple systems, all of the early-decision consequences we described in earlier sections are also transferred to those systems. A product line or family is a set of systems that are all built using the same set of shared assets—software components, requirements documents, test cases, and so forth. Chief among these assets is the architecture that was designed to handle the needs of the entire family. Product-line architects choose an architecture (or a family of closely related architectures) that will serve all envisioned members of the product line. The architecture defines what is fixed for all members of the product line and what is variable. Product lines represent a powerful approach to multi-system development that has shown order-of-magnitude payoffs in time to market, cost, productivity, and product quality. The power of architecture lies at the heart of this paradigm. Similar to other capital investments, architectures for product lines become a developing organization’s shared asset. 2.11 Architecture Allows Incorporation of Independently Developed Elements Whereas earlier software paradigms focused on programming as the prime activity, with prog ress measured in lines of code, architecture-based development often focuses on composing or assembling elements that are likely to have been developed separately, even independently, from each other. This composition is possible because the architecture defines the elements that can be incorporated into the system. The architecture constrains possible replacements (or additions) according to how they interact with their environment, how they receive and relinquish control, which data they consume and produce, how they access data, and which protocols they use for communication and resource sharing. We elaborate on these ideas in Chapter 15. 2.12 Restricting the Vocabulary of Design Alternatives 35 Commercial off-the-shelf components, open source software, publicly available apps, and networked services are all examples of independently developed elements. The complexity and ubiquity of integrating many independently developed elements into your system have spawned an entire industry of software tools, such as Apache Ant, Apache Maven, MSBuild, and Jenkins. For software, the payoffs can take the following forms: Decreased time to market (It should be easier to use someone else’s ready solution than to build your own.) Increased reliability (Widely used software should have its bugs ironed out already.) Lower cost (The software supplier can amortize development cost across its customer base.) Flexibility (If the element you want to buy is not terribly special-purpose, it’s likely to be available from several sources, which in turn increases your buying leverage.) An open system is one that defines a set of standards for software elements—how they behave, how they interact with other elements, how they share data, and so forth. The goal of an open system is to enable, and even encourage, many different suppliers to be able to pro duce elements. This can avoid “vendor lock-in,” a situation in which a single vendor is the only one who can provide an element and charges a premium price for doing so. Open systems are enabled by an architecture that defines the elements and their interactions. 2.12 Restricting the Vocabulary of Design Alternatives As useful architectural solutions are collected, it becomes clear that although software ele ments can be combined in more or less infinite ways, there is something to be gained by voluntarily restricting ourselves to a relatively small number of choices of elements and their interactions. By doing so, we minimize the design complexity of the system we are building. A software engineer is not an artiste where creativity and freedom are paramount. Instead, engineering is about discipline, and discipline comes, in part, by restricting the vocabulary of alternatives to proven solutions. Examples of these proven design solutions include tactics and patterns, which will be discussed extensively in Part II. Reusing off-the-shelf elements is another approach to restricting your design vocabulary. Restricting your design vocabulary to proven solutions can yield the following benefits: Enhanced reuse More regular and simpler designs that are more easily understood and communicated, and bring more reliably predictable outcomes Easier analysis with greater confidence Shorter selection time Greater interoperability 36 Part I Introduction | Chapter 2 Why Is Software Architecture Important? Unprecedented designs are risky. Proven designs are, well, proven. This is not to say that software design can never be innovative or offer new and exciting solutions. It can. But these solutions should not be invented for the sake of novelty; rather, they should be sought when existing solutions are insufficient to solve the problem at hand. Properties of software follow from the choice of architectural tactics or patterns. Tactics and patterns that are more desirable for a particular problem should improve the resulting design solution, perhaps by making it easier to arbitrate conflicting design constraints, by increasing insights into poorly understood design contexts, and by helping surface inconsisten cies in requirements. We will discuss architectural tactics and patterns in Part II","expiryTime":"never","title":"who are you"}