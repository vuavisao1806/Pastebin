{"pasteValue":"These qualities go beyond functionality, which is the basic statement of the system’s capabil ities, services, and behavior. Although functionality and other qualities are closely related, as you will see, functionality often takes the front seat in the development scheme. This prefer ence is shortsighted, however. Systems are frequently redesigned not because they are func tionally deficient—the replacements are often functionally identical—but because they are difficult to maintain, port, or scale; or they are too slow; or they have been compromised by hackers. In Chapter 2, we said that architecture was the first place in software creation in which the achievement of quality requirements could be addressed. It is the mapping of a system’s functionality onto software structures that determines the architecture’s support for qualities. In Chapters 4–14, we discuss how various qualities are supported by architectural design decisions. In Chapter 20, we show how to integrate all of your drivers, including quality attribute decisions, into a coherent design. We have been using the term “quality attribute” loosely, but now it is time to define it more carefully. A quality attribute (QA) is a measurable or testable property of a system that is used to indicate how well the system satisfies the needs of its stakeholders beyond the basic function of the system. You can think of a quality attribute as measuring the “utility” of a product along some dimension of interest to a stakeholder. In this chapter our focus is on understanding the following:    How to express the qualities we want our architecture to exhibit How to achieve the qualities through architectural means How to determine the design decisions we might make with respect to the qualities This chapter provides the context for the discussions of individual quality attributes in Chapters 4–14. 39 40 Part II Quality Attributes | Chapter 3 Understanding Quality Attributes 3.1 Functionality Functionality is the ability of the system to do the work for which it was intended. Of all of the requirements, functionality has the strangest relationship to architecture. First of all, functionality does not determine architecture. That is, given a set of required functionality, there is no end to the architectures you could create to satisfy that functionality. At the very least, you could divide up the functionality in any number of ways and assign the sub-pieces to different architectural elements. In fact, if functionality were the only thing that mattered, you wouldn’t have to divide the system into pieces at all: A single monolithic blob with no internal structure would do just fine. Instead, we design our systems as structured sets of cooperating architectural elements— modules, layers, classes, services, databases, apps, threads, peers, tiers, and on and on—to make them understandable and to support a variety of other purposes. Those “other purposes” are the other quality attributes that we’ll examine in the remaining sections of this chapter, and in the subsequent quality attribute chapters in Part II. Although functionality is independent of any particular structure, it is achieved by assign ing responsibilities to architectural elements. This process results in one of the most basic architectural structures—module decomposition. Although responsibilities can be allocated arbitrarily to any module, software architecture constrains this allocation when other quality attributes are important. For example, systems are frequently (or perhaps always) divided so that several people can cooperatively build them. The architect’s interest in functionality is how it interacts with and constrains other qualities. Functional Requirements After more than 30 years of writing about and discussing the distinction between func tional requirements and quality requirements, the definition of functional requirements still eludes me. Quality attribute requirements are well defined: Performance has to do with the system’s timing behavior, modifiability has to do with the system’s ability to support changes in its behavior or other qualities after initial deployment, availability has to do with the system’s ability to survive failures, and so forth. Function, however, is a much more slippery concept. An international standard (ISO 25010) defines functional suitability as “the capability of the software product to provide functions which meet stated and implied needs when the software is used under spec ified conditions.” That is, functionality is the ability to provide functions. One interpre tation of this definition is that functionality describes what the system does and quality describes how well the system does its function. That is, qualities are attributes of the system and function is the purpose of the system. This distinction breaks down, however, when you consider the nature of some of the ”function.” If the function of the software is to control engine behavior, how can the function be correctly implemented without considering timing behavior? Is the ability to control access by requiring a user name/password combination not a function, even though it is not the purpose of any system? 3.2 Quality Attribute Considerations 41 I much prefer using the word “responsibility” to describe computations that a system must perform. Questions such as “What are the timing constraints on that set of respon sibilities?”, “What modifications are anticipated with respect to that set of responsibili ties?”, and “What class of users is allowed to execute that set of responsibilities?” make sense and are actionable. The achievement of qualities induces responsibility; think of the user name/password example just mentioned. Further, one can identify responsibilities as being associated with a particular set of requirements. So does this mean that the term “functional requirement” shouldn’t be used? People have an understanding of the term, but when precision is desired, we should talk about sets of specific responsibilities instead. Paul Clements has long ranted against the careless use of the term “nonfunctional,” and now it’s my turn to rant against the careless use of the term “functional”—which is probably equally ineffectually. —LB 3.2 Quality Attribute Considerations Just as a system’s functions do not stand on their own without due consideration of quality attributes, neither do quality attributes stand on their own; they pertain to the functions of the system. If a functional requirement is “When the user presses the green button, the Options dialog appears,” a performance QA annotation might describe how quickly the dialog will appear; an availability QA annotation might describe how often this function is allowed to fail, and how quickly it will be repaired; a usability QA annotation might describe how easy it is to learn this function. Quality attributes as a distinct topic have been studied by the software community at least since the 1970s. A variety of taxonomies and definitions have been published (we discuss some of these in Chapter 14), many of which have their own research and practitioner commu nities. However, there are three problems with most discussions of system quality attributes: 1. 2. The definitions provided for an attribute are not testable. It is meaningless to say that a system will be “modifiable.” Every system will be modifiable with respect to one set of changes and not modifiable with respect to another. The other quality attributes are sim ilar in this regard: A system may be robust with respect to some faults and brittle with respect to others, and so forth. Discussion often focuses on which quality a particular issue belongs to. Is a denial of-service attack on a system an aspect of availability, an aspect of performance, an aspect of security, or an aspect of usability? All four attribute communities would claim “ownership” of the denial-of-service attack. All are, to some extent, correct. But this debate over categorization doesn’t help us, as architects, understand and create architec tural solutions to actually manage the attributes of concern. 42 Part II Quality Attributes | Chapter 3 Understanding Quality Attributes 3. Each attribute community has developed its own vocabulary. The performance commu nity has “events” arriving at a system, the security community has “attacks” arriving at a system, the availability community has “faults” arriving, and the usability community has “user input.” All of these may actually refer to the same occurrence, but they are described using different terms. A solution to the first two problems (untestable definitions and overlapping issues) is to use quality attribute scenarios as a means of characterizing quality attributes (see Section 3.3). A solution to the third problem is to illustrate the concepts that are fundamental to that attribute community in a common form, which we do in Chapters 4–14. We will focus on two categories of quality attributes. The first category includes those attributes that describe some property of the system at runtime, such as availability, perfor mance, or usability. The second category includes those that describe some property of the development of the system, such as modifiability, testability, or deployability. Quality attributes can never be achieved in isolation. The achievement of any one will have an effect—sometimes positive and sometimes negative—on the achievement of others. For example, almost every quality attribute negatively affects performance. Take portability: The main technique for achieving portable software is to isolate system dependencies, which intro duces overhead into the system’s execution, typically as process or procedure boundaries, which then hurts performance. Determining a design that may satisfy quality attribute requirements is partially a matter of making the appropriate tradeoffs; we discuss design in Chapter 21. In the next three sections, we focus on how quality attributes can be specified, what archi tectural decisions will enable the achievement of particular quality attributes, and what ques tions about quality attributes will enable the architect to make the correct design decisions. 3.3 Specifying Quality Attribute Requirements: Quality Attribute Scenarios We use a common form to specify all QA requirements as scenarios. This addresses the vocab ulary problems we identified previously. The common form is testable and unambiguous; it is not sensitive to whims of categorization. Thus it provides regularity in how we treat all quality attributes. Quality attribute scenarios have six parts:   Stimulus. We use the term “stimulus” to describe an event arriving at the system or the project. The stimulus can be an event to the performance community, a user operation to the usability community, or an attack to the security community, and so forth. We use the same term to describe a motivating action for developmental qualities. Thus a stimulus for modifiability is a request for a modification; a stimulus for testability is the completion of a unit of development. Stimulus source. A stimulus must have a source—it must come from somewhere. Some entity (a human, a computer system, or any other actor) must have generated the 3.3 Specifying Quality Attribute Requirements: Quality Attribute Scenarios 43   stimulus. The source of the stimulus may affect how it is treated by the system. A request from a trusted user will not undergo the same scrutiny as a request by an untrusted user. Response. The response is the activity that occurs as the result of the arrival of the stim ulus. The response is something the architect undertakes to satisfy. It consists of the responsibilities that the system (for runtime qualities) or the developers (for development time qualities) should perform in response to the stimulus. For example, in a performance scenario, an event arrives (the stimulus) and the system should process that event and generate a response. In a modifiability scenario, a request for a modification arrives (the stimulus) and the developers should implement the modification—without side effects— and then test and deploy the modification. Response measure. When the response occurs, it should be measurable in some fash ion so that the scenario can be tested—that is, so that we can determine if the architect achieved it. For performance, this could be a measure of latency or throughput; for modifiability, it could be the labor or wall clock time required to make, test, and deploy the modification. These four characteristics of a scenario are the heart of our quality attribute specifi cations. But two more characteristics are important, yet often overlooked: environment and artifact.   Environment. The environment is the set of circumstances in which the scenario takes place. Often this refers to a runtime state: The system may be in an overload condition or in normal operation, or some other relevant state. For many systems, “normal” opera tion can refer to one of a number of modes. For these kinds of systems, the environment should specify in which mode the system is executing. But the environment can also refer to states in which the system is not running at all: when it is in development, or testing, or refreshing its data, or recharging its battery between runs. The environment sets the context for the rest of the scenario. For example, a request for a modification that arrives after the code has been frozen for a release may be treated differently than one that arrives before the freeze. The fifth successive failure of a component may be treated differently than the first failure of that component. Artifact. The stimulus arrives at some target. This is often captured as just the system or project itself, but it’s helpful to be more precise if possible. The artifact may be a collection of systems, the whole system, or one or more pieces of the system. A failure or a change request may affect just a small portion of the system. A failure in a data store may be treated differently than a failure in the metadata store. Modifications to the user interface may have faster response times than modifications to the middleware. To summarize, we capture quality attribute requirements as six-part scenarios. While it is common to omit one or more of these six parts, particularly in the early stages of thinking about quality attributes, knowing that all of the parts are there forces the architect to consider whether each part is relevant. We have created a general scenario for each of the quality attributes presented in Chap ters 4–13 to facilitate brainstorming and elicitation of concrete scenarios. We distinguish 44 Part II Quality Attributes | Chapter 3 Understanding Quality Attributes general quality attribute scenarios—general scenarios—which are system independent and can pertain to any system, from concrete quality attribute scenarios—concrete scenarios— which are specific to the particular system under consideration. To translate these generic attribute characterizations into requirements for a particular system, the general scenarios need to be made system specific. But, as we have found, it is much easier for a stakeholder to tailor a general scenario into one that fits their system than it is for them to generate a scenario from thin air. Figure 3.1 shows the parts of a quality attribute scenario just discussed. Figure 3.2 shows an example of a general scenario, in this instance for availability","expiryTime":"never","title":"who are you"}