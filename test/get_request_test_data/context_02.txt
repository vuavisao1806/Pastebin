{"pasteValue":"When we set out to write the fourth edition of Software Architecture in Practice, our first question to ourselves was: Does architecture still matter? With the rise of cloud infrastruc tures, microservices, frameworks, and reference architectures for every conceivable domain and quality attribute, one might think that architectural knowledge is hardly needed anymore. All the architect of today needs to do is select from the rich array of tools and infrastructure alternatives out there, instantiate and configure them, and voila! An architecture. We were (and are) pretty sure this is not true. Admittedly, we are somewhat biased. So we spoke to some of our colleagues—working architects in the healthcare and automotive domains, in social media and aviation, in defense and finance and e-commerce—none of whom can afford to let dogmatic bias rule them. What we heard confirmed our belief—that architecture is just as relevant today as it was more than 20 years ago, when we wrote the first edition. Let’s examine a few of the reasons that we heard. First, the rate of new requirements has been accelerating for many years, and it continues to accelerate even now. Architects today are faced with a nonstop and ever-increasing stream of feature requests and bugs to fix, driven by customer and business needs and by competitive pressures. If architects aren’t paying attention to the modularity of their system (and, no, microservices are not a panacea here), that system will quickly become an anchor—hard to understand, change, debug, and modify, and weigh ing down the business. Second, while the level of abstraction in systems is increasing—we can and do regularly use many sophisticated services, blissfully unaware of how they are implemented—the com plexity of the systems we are being asked to create is increasing at least as quickly. This is an arms race, and the architects aren’t winning! Architecture has always been about taming com plexity, and that just isn’t going to go away anytime soon. Speaking of raising the level of abstraction, model-based systems engineering (MBSE) has emerged as a potent force in the engineering field over the last decade or so. MBSE is the formalized application of modeling to support (among other things) system design. The International Council on Systems Engineering (INCOSE) ranks MBSE as one of a select set of “transformational enablers” that underlie the entire discipline of systems engineering. A model is a graphical, mathematical, or physical representation of a concept or a construct that can be reasoned about. INCOSE is trying to move the engineering field from a document-based men tality to a model-based mentality, where structural models, behavioral models, performance models, and more are all used consistently to build systems better, faster, and cheaper. MBSE per se is beyond the scope of this book, but we can’t help but notice that what is being modeled is architecture. And who builds the models? Architects. xv xvi Preface Third, the meteoric growth (and unprecedented levels of employee turnover) that char acterizes the world of information systems means that no one understands everything in any real-world system. Just being smart and working hard aren’t good enough. Fourth, despite having tools that automate much of what we used to do ourselves—think about all of the orchestration, deployment, and management functions baked into Kubernetes, for example—we still need to understand the quality attribute properties of these systems that we depend upon, and we need to understand the emergent quality attribute properties when we combine systems together. Most quality attributes—performance, security, availability, safety, and so on—are susceptible to “weakest link” problems, and those weakest links may only emerge and bite us when we compose systems. Without a guiding hand to ward off disaster, the composition is very likely to fail. That guiding hand belongs to an architect, regardless of their title. Given these considerations, we felt safe and secure that there was indeed a need for this book. But was there a need for a fourth edition? Again (and this should be abundantly obvious), we concluded an emphatic “yes”! Much has changed in the computing landscape since the last edition was published. Some quality attributes that were not previously considered have risen to importance in the daily lives of many architects. As software continues to pervade all aspects of our society, safety considerations have become paramount for many systems; think about all of the ways that software controls the cars that we now drive. Likewise, energy efficiency is a quality that few architects considered a decade ago, but now must pay attention to, from massive data centers with unquenchable needs for energy to the small (even tiny) battery-operated mobile and IoT devices that surround us. Also, given that we are, more than ever, building systems by leveraging preexisting components, the quality attribute of integra bility is consuming ever-increasing amounts of our attention. Finally, we are building different kinds of systems, and building them in different ways than a decade ago. Systems these days are often built on top of virtualized resources that reside in a cloud, and they need to provide and depend on explicit interfaces. Also, they are increasingly mobile, with all of the opportunities and challenges that mobility brings. So, in this edition we have added chapters on virtualization, interfaces, mobility, and the cloud. As you can see, we convinced ourselves. We hope that we have convinced you as well, and that you will find this fourth edition a useful addition to your (physical or electronic) bookshelf. Register your copy of Software Architecture in Practice, Fourth Edition, on the InformIT site for convenient access to updates and/or corrections as they become available. To start the registration process, go to informit.com/register and log in or create an account. Enter the product ISBN (9780136886099) and click Submit. Look on the Registered Products tab for an Access Bonus Content link next to this product, and follow that link to access any avail able bonus materials. If you would like to be notified of exclusive offers on new editions and updates, please check the box to receive email from us. Acknowledgments We are profoundly grateful to all the people with whom we collaborated to produce this book. First and foremost, we extend our gratitude to the co-authors of individual chapters. Their knowledge and insights in these areas were invaluable. Our thanks go to Cesare Pautasso of the Faculty of Informatics, University of Lugano; Yazid Hamdi of Siemens Mobile Systems; Greg Hartman of Google; Humberto Cervantes of Universidad Autonoma Metropolitana— Iztapalapa; and Yuanfang Cai of Drexel University. Thanks to Eduardo Miranda of Carnegie Mellon University’s Institute for Software Research, who wrote the sidebar on the Value of Information technique. Good reviewers are essential to good work, and we are fortunate to have had John Hudak, Mario Benitez, Grace Lewis, Robert Nord, Dan Justice, and Krishna Guru lend their time and talents toward improving the material in this book. Thanks to James Ivers and Ipek Ozkaya for overseeing this book from the perspective of the SEI Series in Software Engineering. Over the years, we have benefited from our discussions and writings with colleagues and we would like to explicitly acknowledge them. In particular, in addition to those already men tioned, our thanks go to David Garlan, Reed Little, Paulo Merson, Judith Stafford, Mark Klein, James Scott, Carlos Paradis, Phil Bianco, Jungwoo Ryoo, and Phil Laplante. Special thanks go to John Klein, who contributed one way or another to many of the chapters in this book. In addition, we are grateful to everyone at Pearson for all their work and attention to detail in the countless steps involved in turning our words into the finished product that you are now reading. Thanks especially to Haze Humbert, who oversaw the whole process. Finally, thanks to the many, many researchers, teachers, writers, and practitioners who have, over the years, worked to turn software architecture from a good idea into an engineer ing discipline. This book is for you. xvii This page intentionally left blank PART I Introduction 1 What Is Software Architecture? We are called to be architects of the future, not its victims. —R. Buckminster Fuller Writing (on our part) and reading (on your part) a book about software architecture, which distills the experience of many people, presupposes that 1. 2. having a reasonable software architecture is important to the successful development of a software system and there is a sufficient body of knowledge about software architecture to fill up a book. There was a time when both of these assumptions needed justification. Early editions of this book tried to convince readers that both of these assumptions are true and, once you were convinced, supply you with basic knowledge so that you could apply the practice of architec ture yourself. Today, there seems to be little controversy about either aim, and so this book is more about the supplying than the convincing. The basic principle of software architecture is every software system is constructed to satisfy an organization’s business goals, and that the architecture of a system is a bridge between those (often abstract) business goals and the final (concrete) resulting system. While the path from abstract goals to concrete systems can be complex, the good news is that software archi tectures can be designed, analyzed, and documented using known techniques that will support the achievement of these business goals. The complexity can be tamed, made tractable. These, then, are the topics for this book: the design, analysis, and documentation of archi tectures. We will also examine the influences, principally in the form of business goals that lead to quality attribute requirements, that inform these activities. In this chapter, we will focus on architecture strictly from a software engineering point of view. That is, we will explore the value that a software architecture brings to a development project. Later chapters will take business and organizational perspectives. 1 2 Part I Introduction | Chapter 1 What Is Software Architecture? 1.1 What Software Architecture Is and What It Isn’t There are many definitions of software architecture, easily discoverable with a web search, but the one we like is this: The software architecture of a system is the set of structures needed to reason about the system. These structures comprise software elements, relations among them, and properties of both. This definition stands in contrast to other definitions that talk about the system’s “early” or “major” or “important” decisions. While it is true that many architectural decisions are made early, not all are—especially in Agile and spiral-development projects. It’s also true that many decisions that are made early are not what we would consider architectural. Also, it’s hard to look at a decision and tell whether it’s “major.” Sometimes only time will tell. And since deciding on an architecture is one of the architect’s most important obligations, we need to know which decisions an architecture comprises. Structures, by contrast, are fairly easy to identify in software, and they form a powerful tool for system design and analysis. So, there we are: Architecture is about reasoning-enabling structures. Let’s look at some of the implications of our definition. Architecture Is a Set of Software Structures This is the first and most obvious implication of our definition. A structure is simply a set of elements held together by a relation. Software systems are composed of many structures, and no single structure can lay claim to being the architecture. Structures can be grouped into categories, and the categories themselves provide useful ways to think about the architec ture. Architectural structures can be organized into three useful categories, which will play an important role in the design, documentation, and analysis of architectures: 1. Component-and-connector structures 2. Module structures 3. Allocation structures We’ll delve more into these types of structures in the next section. Although software comprises an endless supply of structures, not all of them are archi tectural. For example, the set of lines of source code that contain the letter “z,” ordered by increasing length from shortest to longest, is a software structure. But it’s not a very interesting one, nor is it architectural. A structure is architectural if it supports reasoning about the system and the system’s properties. The reasoning should be about an attribute of the system that is important to some stakeholder(s). These include properties such as the functionality achieved by the system, the system’s ability to keep operating usefully in the face of faults or attempts to take it down, the ease or difficulty of making specific changes to the system, the system’s 1.1 What Software Architecture Is and What It Isn’t 3 responsiveness to user requests, and many others. We will spend a great deal of time in this book exploring the relationship between architecture and quality attributes like these. Thus the set of architectural structures is neither fixed nor limited. What is architectural depends on what is useful to reason about in your context for your system. Architecture Is an Abstraction Since architecture consists of structures, and structures consist of elements1 and relations, it fol lows that an architecture comprises software elements and how those elements relate to each other. This means that architecture specifically and intentionally omits certain information about elements that is not useful for reasoning about the system. Thus an architecture is fore most an abstraction of a system that selects certain details and suppresses others. In all modern systems, elements interact with each other by means of interfaces that partition details about an element into public and private parts. Architecture is concerned with the public side of this divi sion; private details of elements—details having to do solely with internal implementation—are not architectural. This abstraction is essential to taming the complexity of an architecture: We simply cannot, and do not want to, deal with all of the complexity all of the time. We want—and need—the understanding of a system’s architecture to be many orders of magnitude easier than understanding every detail about that system. You can’t keep every detail of a system of even modest size in your head; the point of architecture is to make it so you don’t have to. Architecture versus Design Architecture is design, but not all design is architecture. That is, many design decisions are left unbound by the architecture—it is, after all, an abstraction—and depend on the discretion and good judgment of downstream designers and even implementers. Every Software System Has a Software Architecture Every system has an architecture, because every system has elements and relations. However, it does not follow that the architecture is known to anyone. Perhaps all of the people who designed the system are long gone, the documentation has vanished (or was never produced), the source code has been lost (or was never delivered), and all we have at hand is the exe cuting binary code. This reveals the difference between the architecture of a system and the representation of that architecture. Given that an architecture can exist independently of its description or specification, this raises the importance of architecture documentation, which is described in Chapter 22. 1. In this book, we use the term “element” when we mean either a module or a component, and don’t want to distin guish between the two. 4 Part I Introduction | Chapter 1 What Is Software Architecture? Not All Architectures Are Good Architectures Our definition is indifferent as to whether the architecture for a system is a good one or a bad one. An architecture may either support or hinder achieving the important requirements for a system. Assuming that we do not accept trial and error as the best way to choose an archi tecture for a system—that is, picking an architecture at random, building the system from it, and then hacking away and hoping for the best—this raises the importance of architecture design, which is treated in Chapter 20 and architecture evaluation, which will be dealt with in Chapter 21. Architecture Includes Behavior The behavior of each element is part of the architecture insofar as that behavior can help you reason about the system. The behavior of elements embodies how they interact with each other and with the environment. This is clearly part of our definition of architecture and will have an effect on the properties exhibited by the system, such as its runtime performance. Some aspects of behavior are below the architect’s level of concern. Nevertheless, to the extent that an element’s behavior influences the acceptability of the system as a whole, this behavior must be considered part of the system’s architectural design, and should be docu mented as such. System and Enterprise Architectures Two disciplines related to software architecture are system architecture and enterprise architecture. Both of these disciplines have broader concerns than software and affect software architecture through the establishment of constraints within which a software system, and its architect, must live. System Architecture A system’s architecture is a representation of a system in which there is a mapping of functionality onto hardware and software components, a mapping of the software architecture onto the hardware architecture, and a concern for the human interaction with these components. That is, system architecture is concerned with the totality of hardware, software, and humans. A system architecture will influence, for example, the functionality that is assigned to different processors and the types of networks that connect those processors. The software architecture will determine how this functionality is structured and how the software programs residing on the various processors interact. A description of the software architecture, as it is mapped to hardware and network ing components, allows reasoning about qualities such as performance and reliability. A description of the system architecture will allow reasoning about additional qualities such as power consumption, weight, and physical dimensions. When designing a particular system, there is frequently negotiation between the system architect and the software architect over the distribution of functionality and, consequently, the constraints placed on the software architecture. 1.2 Architectural Structures and Views 5 Enterprise Architecture Enterprise architecture is a description of the structure and behavior of an organiza tion’s processes, information flow, personnel, and organizational subunits. An enterprise architecture need not include computerized information systems—clearly, organizations had architectures that fit the preceding definition prior to the advent of computers—but these days enterprise architectures for all but the smallest businesses are unthinkable without information system support. Thus a modern enterprise architecture is con cerned with how software systems support the enterprise’s business processes and goals. Typically included in this set of concerns is a process for deciding which systems with which functionality the enterprise should support. An enterprise architecture will specify, for example, the data model that various sys tems use to interact. It will also specify rules for how the enterprise’s systems interact with external systems. Software is only one concern of enterprise architecture. How the software is used by humans to perform business processes and the standards that determine the computational environment are two other common concerns addressed by enterprise architecture. Sometimes the software infrastructure that supports communication among systems and with the external world is considered a portion of the enterprise architecture; at other times, this infrastructure is considered one of the systems within an enterprise. (In either case, the architecture of that infrastructure is a software architecture!) These two views will result in different management structures and spheres of influence for the individuals concerned with the infrastructure. Are These Disciplines in Scope for This Book? Yes! (Well, No.) The system and the enterprise provide environments for, and constraints on, the software architecture. The software architecture must live within the system and the enterprise, and increasingly is the focus for achieving the organization’s business goals. Enterprise and system architectures share a great deal with software architec tures. All can be designed, evaluated, and documented; all answer to requirements; all are intended to satisfy stakeholders; all consist of structures, which in turn consist of elements and relationships; all have a repertoire of patterns at their respective archi tects’ disposal; and the list goes on. So to the extent that these architectures share commonalities with software architecture, they are in the scope of this book. But like all technical disciplines, each has its own specialized vocabulary and techniques, and we won’t cover those. Copious other sources exist that do. 1.2 Architectural Structures and Views Because architectural structures are at the heart of our definition and treatment of software architecture, this section will explore these concepts in more depth. These concepts are dealt with in much greater depth in Chapter 22, where we discuss architecture documentation. Architectural structures have counterparts in nature. For example, the neurologist, the orthopedist, the hematologist, and the dermatologist all have different views of the various 6 Part I Introduction | Chapter 1 What Is Software Architecture? structures of a human body, as illustrated in Figure 1.1. Ophthalmologists, cardiologists, and podiatrists concentrate on specific subsystems. Kinesiologists and psychiatrists are concerned with different aspects of the entire arrangement’s behavior. Although these views are pictured differently and have very different properties, all are inherently related and interconnected: Together they describe the architecture of the human body. FIGURE 1.1 Physiological structures Architectural structures also have counterparts in human endeavors. For example, elec tricians, plumbers, heating and air conditioning specialists, roofers, and framers are each con cerned with different structures in a building. You can readily see the qualities that are the focus of each of these structures. So it is with software. 1.2 Architectural Structures and Views 7 Three Kinds of Structures Architectural structures can be divided into three major categories, depending on the broad nature of the elements they show and the kinds of reasoning they support: 1. 2. Component-and-connector (C&C) structures focus on the way the elements interact with each other at runtime to carry out the system’s functions. They describe how the system is structured as a set of elements that have runtime behavior (components) and interactions (connectors). Components are the principal units of computation and could be services, peers, clients, servers, filters, or many other types of runtime element. Connectors are the communication vehicles among components, such as call-return, process synchronization operators, pipes, or others. C&C structures help answer ques tions such as the following: What are the major executing components and how do they interact at runtime? What are the major shared data stores? Which parts of the system are replicated? How does data progress through the system? Which parts of the system can run in parallel? Can the system’s structure change as it executes and, if so, how? By extension, these structures are crucially important for asking questions about the system’s runtime properties, such as performance, security, availability, and more. C&C structures are the most common ones that we see, but two other categories of structures are important and should not be overlooked. Figure 1.2 shows a sketch of a C&C structure of a system using an informal notation that is explained in the figure’s key. The system contains a shared repository that is accessed by servers and an administrative component. A set of client tellers can interact with the account servers and communicate among themselves using a publish-subscribe connector. Module structures partition systems into implementation units, which in this book we call modules. Module structures show how a system is structured as a set of code or data units that have to be constructed or procured. Modules are assigned specific computa tional responsibilities and are the basis of work assignments for programming teams. In any module structure, the elements are modules of some kind (perhaps classes, packages, layers, or merely divisions of functionality, all of which are units of implementation). Modules represent a static way of considering the system. Modules are assigned areas of functional responsibility; there is less emphasis in these structures on how the resulting software manifests itself at runtime. Module implementations include packages, classes, and layers. Relations among modules in a module structure include uses, generalization (or “is-a”), and “is part of.” Figures 1.3 and 1.4 show examples of module elements and relations, respectively, using the Unified Modeling Language (UML) notation","expiryTime":"never","title":"who are you"}