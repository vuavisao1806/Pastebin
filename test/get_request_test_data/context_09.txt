{"pasteValue":"This chapter describes the concepts surrounding interfaces, and discusses how to design and document them. An interface, software or otherwise, is a boundary across which elements meet and interact, communicate, and coordinate. Elements have interfaces that control access to their internals. Elements may also be subdivided, with each sub-element having its own interface. An element’s actors are the other elements, users, or systems with which it interacts. The collection of actors with which an element interacts is called the environment of the element. By “interacts,” we mean anything one element does that can impact the processing of another element. This interaction is part of the element’s interface. Interactions can take a variety of forms, though most involve the transfer of control and/or data. Some are supported by stan dard programming-language constructs, such as local or remote procedure calls (RPCs), data streams, shared memory, and message passing. These constructs, which provide points of direct interaction with an element, are called resources. Other interactions are indirect. For example, the fact that using resource X on element A leaves element B in a particular state is something that other elements using the resource may need to know if it affects their processing, even though they never interact with element A directly. That fact about A is a part of the interface between A and the other ele ments in A’s environment. In this chapter, we focus only on the direct interactions. 217 218 Part III Architectural Solutions | Chapter 15 Software Interfaces Recall that, in Chapter 1, we defined architecture in terms of elements and their rela tionships. In this chapter, we focus on one type of relationship. Interfaces are a fundamen tal abstraction mechanism necessary to connect elements together. They have an outsized impact on a system’s modifiability, usability, testability, performance, integrability, and more. Furthermore, asynchronous interfaces, which are commonly part of distributed systems, require event handlers—an architectural element. For a given element’s interface, there can be one or more implementations, each of which might have different performance, scalability, or availability guarantees. Likewise, different implementations for the same interface may be constructed for different platforms. Three points are implied by the discussion thus far: 1. 2. 3. All elements have interfaces. All elements interact with some actors; otherwise, what is the point of the element’s existence? Interfaces are two-way. When considering interfaces, most software engineers first think of a summary of what an element provides. What methods does the element make avail able? What events does it process? But an element also interacts with its environment by making use of resources external to it or by assuming that its environment behaves in a certain way. If these resources are missing or if the environment doesn’t behave as expected, the element can’t function correctly. So an interface is more than what is pro vided by an element; an interface also includes what is required by an element. An element can interact with more than one actor through the same interface. For example, web servers often restrict the number of HTTP connections that can be open simultaneously. 15.1 Interface Concepts In this section, we discuss the concepts of multiple interfaces, resources, operations, proper ties, and events, as well as the evolution of interfaces. Multiple Interfaces It is possible to split a single interface into multiple interfaces. Each of these has a related logical purpose, and serves a different class of actors. Multiple interfaces provide a kind of separation of concerns. A specific class of actor might require only a subset of the function ality available; this functionality can be provided by one of the interfaces. Conversely, the provider of an element may want to grant actors different access rights, such as read or write, or to implement a security policy. Multiple interfaces support different levels of access. For example, an element might expose its functionality through its main interface and give access to debugging or performance monitoring data or administrative functions via separate inter faces. There may be public read-only interfaces for anonymous actors and private interfaces that allow authenticated and authorized actors to modify the state of an element. 15.1 Interface Concepts 219 Resources Resources have syntax and semantics:   Resource syntax. The syntax is the resource’s signature, which includes any information that another program will need to write a syntactically correct program that uses the resource. The signature includes the name of the resource, the names and data types of arguments, if any, and so forth. Resource semantics. What is the result of invoking this resource? Semantics come in a variety of guises, including the following:       Assignment of values to data that the actor invoking the resource can access. The value assignment might be as simple as setting the value of a return argument or as far-reaching as updating a central database. Assumptions about the values crossing the interface. Changes in the element’s state brought about by using the resource. This includes exceptional conditions, such as side effects from a partially completed operation. Events that will be signaled or messages that will be sent as a result of using the resource. How other resources will behave differently in the future as the result of using this resource. For example, if you ask a resource to destroy an object, trying to access that object in the future through other resources could produce an error as a result. Humanly observable results. These are prevalent in embedded systems. For example, calling a program that turns on a display in a cockpit has a very observable effect—the display comes on. In addition, the statement of semantics should make it clear whether the execution of the resource will be atomic or may be suspended or interrupted. Operations, Events, and Properties The resources of provided interfaces consist of operations, events, and properties. These resources are complemented by an explicit description of the behavior caused or data exchanged when accessing each interface resource in terms of its syntax, structure, and semantics. (Without this description, how would the programmer or actor know whether or how to use the resources?) Operations are invoked to transfer control and data to the element for processing. Most operations also return a result. Operations may fail, and as part of the interface it should be clear how actors can detect errors, either signaled as part of the output or through some dedi cated exception-handling channel. In addition, events—which are normally asynchronous—may be described in interfaces. Incoming events can represent the receipt of a message taken from a queue, or the arrival of a stream element that is to be consumed. Active elements—those that do not passively wait to be invoked by other elements—produce outgoing events used to notify listeners (or subscribers) about interesting things happening within the element. In addition to the data transferred via operations and events, an important aspect of inter faces is metadata, such as access rights, units of measure, or formatting assumptions. Another 220 Part III Architectural Solutions | Chapter 15 Software Interfaces name for this interface metadata is properties. Property values can influence the behavior of operations, as highlighted in the quotation that began this chapter. Property values also affect the behavior of the element, depending on its state. Complex interfaces of elements that are both stateful and active will feature a combina tion of operations, events, and properties. Interface Evolution All software evolves, including interfaces. Software that is encapsulated by an interface is free to evolve without impact to the elements that use this interface as long as the interface itself does not change. An interface, however, is a contract between an element and its actors. Just as a legal contract can be changed only within certain constraints, software interfaces should be changed with care. Three techniques can be used to change an interface: deprecation, version ing, and extension.    Deprecation. Deprecation means removing an interface. Best practice when deprecat ing an interface is to give extensive notice to the actors of the element. This warning, in theory, allows the actors time to adjust to the interface’s removal. In practice, many actors will not adjust in advance, but rather will discover the deprecation only when the interface is removed. One technique when deprecating an interface is to introduce an error code signifying that this interface is to be deprecated at (specific date) or that this interface has been deprecated. Versioning. Multiple interfaces support evolution by keeping the old interface and adding a new one. The old one can be deprecated when it is no longer needed or the decision has been made to no longer support it. This requires the actor to specify which version of an interface it is using. Extension. Extending an interface means leaving the original interface unchanged and adding new resources to the interface that embody the desired changes. Figure 15.1(a) shows the original interface. If the extension does not contain any incompatibilities with the original interface, then the element can implement the external interface directly, as shown in Figure 15.1(b). In contrast, if the extension introduces some incom patibilities, then it is necessary to have an internal interface for the element and to add a mediator to translate between the external interface and the internal interface, as shown in Figure 15.1(c). As an example of an incompatibility, suppose the original interface assumed that apartment numbers were included in the address but the extended interface broke out apartment numbers as a separate parameter. The internal interface would have the apartment number as a separate parameter. Then the mediator, if invoked from the original interface, would parse the address to determine any apartment number, whereas the mediator would pass the apartment number included in the separate parameter on to the internal interface unchanged","expiryTime":"never","title":"who are you"}